/* * Loglet Lab 2.0 *  * Copyright (c) 2003, Program for the Human Environment, The Rockefeller University, * except where noted. All rights reserved. *  * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: *  * 1. Redistributions of source code must retain the above copyright notice, this *    list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, *    this list of conditions and the following disclaimer in the documentation *    and/or other materials provided with the distribution. * 3. Neither the name of The Program for the Human Environment nor The Rockefeller *    University nor the names of its contributors may be used to endorse or  *    promote products derived from this software without specific prior *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH * DAMAGE. *  */package org.logletlab;import java.util.*;import java.util.regex.*;import java.io.*;import java.awt.Color;import org.jdom2.CDATA;import org.jdom2.Comment;import org.jdom2.Content;import org.jdom2.Document;import org.jdom2.Element;import org.jdom2.EntityRef;import org.jdom2.JDOMException;import org.jdom2.ProcessingInstruction;import org.jdom2.Text;import org.jdom2.input.SAXBuilder;import org.jdom2.output.XMLOutputter;import org.logletlab.model.AbstractFitModel;import org.logletlab.model.AbstractFitParameters;import org.logletlab.model.LogisticFitModel;import org.logletlab.ui.PlotRenderer;import jxl.*;import jxl.read.biff.BiffException;public class LogletLabDocument implements java.io.Serializable {	private File file;	/**	 * Document title	 */	String title = "untitled";	/**	 * x-axis label	 */	String domainLabel = "time";	/**	 * y-axis label	 */	String rangeLabel = "y";	/**	 * the data	 */	private List<LogletLabDataSet> dataSets;		/**	 * the fit models that have been applied to these data	 */	List<AbstractFitModel> fits;	// table-related variables	private int currentDataSet;		// RENDERING PREFERENCES FOR THESE DATA	/**	 * available colors for plotting	 */	private Color[] plotColors = { Color.BLACK, new Color(0,0,255), new Color(0,153,0), new Color(153,0,0),		new Color(255,153,0), new Color(153,0,153), new Color(0,153,153), new Color(153,153,0) };	/**	 * auto-manage bounds?	 */	private boolean autoXAxisOn = true, autoYAxisOn = true;	/**	 * axis bounds	 */	private double tMin, tMax, yMin, yMax;		/**	 * Axis type (lin-lin or lin-log)	 */	private int axisType;			/**	 * is the document modified? (i.e., prompt for save before closing?)	 */	boolean modified;		public LogletLabDocument() {		dataSets = new ArrayList<LogletLabDataSet>();		fits = new ArrayList<AbstractFitModel>();		axisType = PlotRenderer.AXIS_LINEAR;	//default	}	public void addDataSet(LogletLabDataSet ds) {		ds.setDoc(this);		dataSets.add(ds);		ds.setColor(plotColors[dataSets.size()-1]);		setCurrentDataSet(dataSets.size()-1);	}		public LogletLabDataSet getDataSet(int i) {		if (i >= dataSets.size())			return null;		else			return dataSets.get(i);	}	public LogletLabDataSet getCurrentDataSet() {		return getDataSet(currentDataSet);	}	/**	 * @param i	 */	public void setCurrentDataSet(int i) {		currentDataSet = i;	}	public int getNSets() {		return dataSets.size();	}	public AbstractFitModel addFit(AbstractFitModel afm) {		fits.add(afm);		return afm;	}	public AbstractFitModel getFit(int i) {		if (i > fits.size() - 1)			return null;		else			return fits.get(i);	}	public int getNFits() {		return fits.size();	}	// document handler	public void openDocument(java.io.File f) throws IOException, BiffException {		//addDataSet(new LogletLabDataSet());		String ext = null;		String s = f.getName();		int index = s.lastIndexOf('.');		if (index > 0 && index < s.length() - 1) {			ext = s.substring(index + 1).toLowerCase();			if (ext.equals("xml")) {				openXMLFile(f);			} else if (ext.equals("xls")) {				openExcelFile(f);			} else {				openTextFile(f);			}			setModified(false);		}		else		{			// Try opening as a text file			openTextFile(f);		}	}	private void openXMLFile(java.io.File f) throws IOException {		SAXBuilder builder = new SAXBuilder();		try {			Document doc = builder.build(f);			processNodes(doc, 0);			setFile(f);		} catch (JDOMException e) {			System.out.println(f + " is not well-formed.");			System.out.println(e.getMessage());		} 	}	private void openExcelFile(java.io.File f) throws IOException, BiffException {		// assume one data set.		addDataSet(new LogletLabDataSet());		Workbook workbook = Workbook.getWorkbook(f);		Sheet sheet = workbook.getSheet(0);		int offset = 0;		// Meta data		this.setTitle(sheet.getName());		Cell a1 = sheet.getCell(0, 0);		if (a1.getType() == CellType.LABEL) {			LabelCell lc = (LabelCell) a1;			this.setDomainLabel(lc.getString());			offset = 1;		}		Cell a2 = sheet.getCell(1, 0);		if (a2.getType() == CellType.LABEL) {			LabelCell lc = (LabelCell) a2;			this.setRangeLabel(lc.getString());			offset = 1;		}		// read the cells		LogletLabDataSet ds = this.getCurrentDataSet();		for (int i = offset; i < sheet.getRows(); i++) {			Cell[] cells = sheet.getRow(i);			if (cells[0].getType() == CellType.NUMBER				&& cells[1].getType() == CellType.NUMBER) {				double x = ((NumberCell) cells[0]).getValue();				double y = ((NumberCell) cells[1]).getValue();				//System.err.println(x+","+y);				ds.addPoint(x, y, false);			}		}		// close workbook		workbook.close();	}	private void openTextFile(java.io.File f) throws IOException {		// assume data set		addDataSet(new LogletLabDataSet());				BufferedReader in = new BufferedReader(new FileReader(f));		String line = in.readLine();					if (line.startsWith("<?xml")) {			// try to read this as an XML file instead			in.close();			openXMLFile(f);			return;		} else {			in.close();		}					parseText(new BufferedReader(new FileReader(f)));	}	public void parseText(BufferedReader reader) throws IOException {		LogletLabDataSet ds = this.getCurrentDataSet();		String line = "";		while ((line = reader.readLine()) != null) {			//System.err.println(":"+line);			Pattern dataPattern = Pattern.compile("^(\\d+\\.*\\d+)[\\s|,]+(\\d+\\.*\\d+).*$");			Matcher matches = dataPattern.matcher(line);			if (matches.matches() && matches.groupCount() >= 2) {				double x = Double.parseDouble(matches.group(1));				double y = Double.parseDouble(matches.group(2));				System.err.println(matches.group(1)+","+matches.group(2));				ds.addPoint(x, y, false);			}		}		reader.close();	}	public void saveDocument(java.io.File f) {		//CREATE XML ROOT		Element root = new Element("LogletLabDocument");		// TITLE		Element titleNode = new Element("TITLE");		titleNode.setText(title);		root.addContent(titleNode);		// COLUMN HEADERS		Element domainNode = new Element("DOMAIN");		domainNode.setAttribute("auto", String.valueOf(isAutoXAxisOn()));		domainNode.setAttribute("min", String.valueOf(getTMin()));		domainNode.setAttribute("max", String.valueOf(getTMax()));		domainNode.setText(domainLabel);		root.addContent(domainNode);		Element rangeNode = new Element("RANGE");		rangeNode.setText(rangeLabel);		rangeNode.setAttribute("auto", String.valueOf(isAutoYAxisOn()));		rangeNode.setAttribute("min", String.valueOf(getYMin()));		rangeNode.setAttribute("max", String.valueOf(getYMax()));		root.addContent(rangeNode);		// foreach data set:		for (int i = 0; i < getNSets(); i++) {			Element tableNode = new Element("table");			tableNode.setAttribute("name",getDataSet(i).getDataSetName());			LogletLabDataSet ds = getDataSet(i);			// Put in column names for XSIL compatibilty			// x-axis			Element domainColNode = new Element("Column");			domainColNode.setAttribute("name", domainLabel);			domainColNode.setAttribute("type", "double");			tableNode.addContent(domainColNode);			// y-axis			Element rangeColNode = new Element("Column");			rangeColNode.setAttribute("name", rangeLabel);			rangeColNode.setAttribute("type", "double");			tableNode.addContent(rangeColNode);			// exclude			Element excNode = new Element("Column");			excNode.setAttribute("name", "exclude");			excNode.setAttribute("type", "boolean");			tableNode.addContent(excNode);						// THE DATA			Element dataNode = new Element("stream");			dataNode.setAttribute("delimiter", ",");			String data = "\n";			for (int j = 0; j < ds.getNPoints(); j++) {				org.logletlab.util.DPoint dp = ds.getPoint(j);				data += "\t" + dp.toString() + "," + "\n";			}			dataNode.setText(data);			tableNode.addContent(dataNode);			for (AbstractFitModel j : ds.fits.keySet()) 			{				AbstractFitParameters afm =					ds.getFitParameters(j);				Element fitNode = new Element("fit");				fitNode.setAttribute("name", afm.fitName);				Map<String, String> params = afm.getParams();				for (String paramName : params.keySet()) {					Element paramNode = new Element("param");					paramNode.setAttribute("name", paramName);					paramNode.setAttribute(						"value", params.get(paramName));					fitNode.addContent(paramNode);				}				tableNode.addContent(fitNode);			}			root.addContent(tableNode);		}		//CREATE A DOCUMENT FROM THE JDOM TREE		Document doc = new Document(root);		XMLOutputter outputter = new XMLOutputter();		//outputter.setIndent("  "); // use two space indent		//outputter.setNewlines(true);		// Write the document out to the file		try {			FileOutputStream out = new FileOutputStream(f);			outputter.output(doc, out);			out.close();			//outputter.output(doc, System.err);       		} catch (IOException e) {			System.err.println(e);		}		setModified(false);	}	public void processNodes(Object o, int depth) {		//printSpaces(depth);		if (o instanceof Element) {			Element element = (Element) o;			//System.out.println("Element: " + element.getName());			if (element.getName().trim().toUpperCase().equals("TABLE")) {				// NEW DATA SET				if (element.getAttribute("name") != null) {					addDataSet(new LogletLabDataSet(element.getAttributeValue("name")));				} else {					addDataSet(new LogletLabDataSet());				}			} else if (element.getName().trim().toUpperCase().equals("DOMAIN")) {				if (element.getAttribute("auto") != null) {					setAutoXAxisOn(Boolean.getBoolean(element.getAttributeValue("auto")));				} else {					setAutoXAxisOn(true);				}				if (element.getAttribute("min") != null) {					setTMin(Double.parseDouble(element.getAttributeValue("min")));				}				if (element.getAttribute("max") != null) {					setTMax(Double.parseDouble(element.getAttributeValue("max")));				}			} else if (element.getName().trim().toUpperCase().equals("RANGE")) {				if (element.getAttribute("auto") != null) {					setAutoYAxisOn(Boolean.getBoolean(element.getAttributeValue("auto")));				} else {					setAutoYAxisOn(true);				}				if (element.getAttribute("min") != null) {					setYMin(Double.parseDouble(element.getAttributeValue("min")));				}				if (element.getAttribute("max") != null) {					setYMax(Double.parseDouble(element.getAttributeValue("max")));				}			} else if (element.getName().trim().toUpperCase().equals("COLUMN")) {				if (domainLabel == null) {					setDomainLabel(element.getAttributeValue("name"));				} else if (rangeLabel == null) {					setRangeLabel(element.getAttributeValue("name"));				}			} else if (element.getName().trim().toUpperCase().equals("FIT")) {				// children nodes are parameters				String fitName = element.getAttributeValue("name");				try {					// Try to instantiate that class					Class afmClass =						Class.forName("LogletLab.AbstractFitModel");					Class fitClass = Class.forName(fitName);					if (afmClass.isAssignableFrom(fitClass)) {						// Create the fit object.						AbstractFitModel fit =							(AbstractFitModel) fitClass.newInstance();						// Check if we already have one.						for (int i = 0; i < this.getNFits(); i++) {							if (fitClass.isInstance(this.getFit(i))) {								fit = this.getFit(i);								break;							}						}												// Get the parameters from the child nodes.						Hashtable<String, String> fitParams = new Hashtable<String, String>();						List<Content> children = element.getContent();						Iterator iterator = children.iterator();						while (iterator.hasNext()) {							Object child = iterator.next();							// get the params from this child.							if (child instanceof Element) {								Element param = (Element) child;								fitParams.put(param.getAttributeValue("name"),param.getAttributeValue("value"));							}						}						// The FitModel has to have create from hashtable mothod						// It should also initialize itself based on the parameters.						this.getCurrentDataSet().fits.put(fit,fit.createParameters(fitParams,this.getCurrentDataSet()));						fits.add(fit);						return;					}				} catch (ClassNotFoundException e) {					// Do nothing; just drop it.					System.err.println("Fit class not found: " + fitName);					LogisticFitModel lfm = new LogisticFitModel(1);					System.err.println(lfm.getClass().getName());				} catch (InstantiationException e) {					System.err.println(						"Couldn't instantiate class: " + fitName);				} catch (IllegalAccessException e) {					e.printStackTrace();				}			}			List<Content> children = element.getContent();			Iterator iterator = children.iterator();			while (iterator.hasNext()) {				Object child = iterator.next();				processNodes(child, depth + 1);			}		} else if (o instanceof Document) {			//System.out.println("Document");			Document tmpdoc = (Document) o;			List<Content> children = tmpdoc.getContent();			Iterator iterator = children.iterator();			while (iterator.hasNext()) {				Object child = iterator.next();				processNodes(child, depth + 1);			}		} else if (o instanceof Comment) {			//System.out.println("Comment");		} else if (o instanceof CDATA) {			System.out.println("CDATA section");			// CDATA is a subclass of Text so this test must come			// before the test for Text.		} else if (o instanceof Text) {			Text txt = (Text) o;			if (txt.getParent().getName().toUpperCase().equals("TITLE")) {				//System.err.println("Title="+txt.getText());				setTitle(txt.getText());			} else if (				txt.getParent().getName().toUpperCase().equals("DOMAIN")) {				setDomainLabel(txt.getText());			} else if (				txt.getParent().getName().toUpperCase().equals("RANGE")) {				setRangeLabel(txt.getText());			} else if (				txt.getParent().getName().toUpperCase().equals("STREAM")) {				// System.err.println("stream:");				LogletLabDataSet ds = getDataSet(getNSets() - 1);				String[] pts = txt.getText().split(",");				int nPts = pts.length / 3;				for (int i = 0; i < nPts; i++) {					double x = Double.parseDouble(pts[i * 3]);					double y = Double.parseDouble(pts[i * 3 + 1]);					boolean ex = Boolean.getBoolean(pts[i * 3 + 2]);					// System.err.println(x+","+y+","+ex);					ds.addPoint(x, y, ex);				}			} else {				//System.out.println("Text");			}		} else if (o instanceof EntityRef) {			System.out.println("Entity reference");		} else if (o instanceof ProcessingInstruction) {			System.out.println("Processing Instruction");		} else { // This really shouldn't happen			System.out.println("Unexpected type: " + o.getClass());		}	}	public String getTitle() {		return title;	}	public void setTitle(String t) {		title = t;	}	public String getDomainLabel() {		return domainLabel;	}	public void setDomainLabel(String label) {		domainLabel = label;	}	public String getRangeLabel() {		return rangeLabel;	}	public void setRangeLabel(String label) {		rangeLabel = label;	}	public void setModified(boolean b) {		modified = b;	}	public boolean getModified() {		return modified;	}	/**	 * @return	 */	public boolean isAutoXAxisOn() {		return autoXAxisOn;	}	/**	 * @return	 */	public boolean isAutoYAxisOn() {		return autoYAxisOn;	}	/**	 * @return	 */	public double getTMax() {		return tMax;	}	/**	 * @return	 */	public double getTMin() {		return tMin;	}	/**	 * @return	 */	public double getYMax() {		return yMax;	}	/**	 * @return	 */	public double getYMin() {		return yMin;	}	/**	 * @param b	 */	public void setAutoXAxisOn(boolean b) {		autoXAxisOn = b;	}	/**	 * @param b	 */	public void setAutoYAxisOn(boolean b) {		autoYAxisOn = b;	}	/**	 * @param d	 */	public void setTMax(double d) {		tMax = d;	}	/**	 * @param d	 */	public void setTMin(double d) {		tMin = d;	}	/**	 * @param d	 */	public void setYMax(double d) {		yMax = d;	}	/**	 * @param d	 */	public void setYMin(double d) {		yMin = d;	}	/**	 * @return	 */	public int getAxisType() {		return axisType;	}	/**	 * @param i	 */	public void setAxisType(int i) {		axisType = i;	}	public File getFile() {		return file;	}	public void setFile(File myFile) {		this.file = myFile;	}}